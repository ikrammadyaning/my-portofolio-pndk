<!doctype html>
<html lang="id" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pacman Game</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      box-sizing: border-box;
    }
    
    .game-container {
      max-width: 700px;
      margin: 0 auto;
    }
    
    #gameCanvas {
      border: 4px solid #fbbf24;
      border-radius: 12px;
      background: #0f172a;
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 30px rgba(251, 191, 36, 0.3);
    }
    
    .joystick-container {
      position: relative;
      width: 150px;
      height: 150px;
      margin: 0 auto;
    }
    
    .joystick-base {
      position: absolute;
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: rgba(30, 41, 59, 0.8);
      border: 3px solid #475569;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    .joystick-stick {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      border: 3px solid #d97706;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .joystick-stick:active {
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full overflow-auto">
  <div id="app" class="min-h-full w-full p-6" style="background: linear-gradient(135deg, #1e1b4b 0%, #581c87 100%);">
   <div class="game-container"><!-- Header -->
    <div class="text-center mb-6">
     <h1 id="game-title" class="text-5xl font-bold mb-4" style="color: #fbbf24; text-shadow: 3px 3px 6px rgba(0,0,0,0.7);">üü° PACMAN GAME</h1>
     <div class="flex justify-center gap-8 text-xl font-bold">
      <div><span id="score-label" style="color: #fbbf24;">Skor: </span> <span id="score" style="color: #ffffff;">0</span>
      </div>
      <div><span style="color: #fbbf24;">Level: </span> <span id="level" style="color: #ffffff;">1</span>
      </div>
      <div><span id="lives-label" style="color: #fbbf24;">Nyawa: </span> <span id="lives" style="color: #ffffff;">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
      </div>
     </div>
     <div id="power-up-timer" class="mt-2 text-lg font-bold" style="color: #22d3ee; display: none;">
      ‚ö° POWER MODE: <span id="power-time">0</span>s
     </div>
    </div><!-- Game Canvas -->
    <canvas id="gameCanvas" width="600" height="600"></canvas><!-- Controls -->
    <div class="mt-8">
     <div class="joystick-container" id="joystick-container">
      <div class="joystick-base"></div>
      <div class="joystick-stick" id="joystick-stick"></div>
     </div><!-- Instructions -->
     <div class="mt-6 text-center" style="color: #fef3c7;">
      <p class="text-sm font-semibold">üïπÔ∏è Gunakan analog stick atau keyboard (WASD/Arrow) untuk bergerak</p>
      <p class="text-sm">üü° Kumpulkan koin kuning ‚Ä¢ üî¥ Makan power pellet untuk balas dendam!</p>
      <p class="text-sm">üëª Hindari hantu ‚Ä¢ ‚ö° Saat power mode: makan hantu untuk poin ekstra!</p>
     </div>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: "üü° PACMAN GAME",
      score_label: "Skor: ",
      lives_label: "Nyawa: ",
      background_gradient_start: "#1e1b4b",
      background_gradient_end: "#581c87",
      pacman_color: "#fbbf24",
      power_pellet_color: "#ef4444",
      font_family: "system-ui",
      font_size: 16
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const CELL_SIZE = 30;
    const GRID_WIDTH = 20;
    const GRID_HEIGHT = 20;
    
    let pacman = { x: 1, y: 1, direction: 'right', nextDirection: 'right', mouthOpen: true, speed: 0.15 };
    let ghosts = [];
    let score = 0;
    let level = 1;
    let lives = 3;
    let coins = [];
    let powerPellets = [];
    let walls = [];
    let gameLoop;
    let moveCounter = 0;
    let powerMode = false;
    let powerModeTimer = 0;
    let eatenGhosts = [];
    let ghostRespawnTimers = [];
    
    // Joystick variables
    let joystickActive = false;
    let joystickX = 0;
    let joystickY = 0;
    const joystickStick = document.getElementById('joystick-stick');
    const joystickContainer = document.getElementById('joystick-container');
    
    // Create maze
    function createMaze() {
      walls = [];
      // Border walls
      for (let x = 0; x < GRID_WIDTH; x++) {
        walls.push({ x, y: 0 });
        walls.push({ x, y: GRID_HEIGHT - 1 });
      }
      for (let y = 0; y < GRID_HEIGHT; y++) {
        walls.push({ x: 0, y });
        walls.push({ x: GRID_WIDTH - 1, y });
      }
      
      // Inner walls - create a more complex maze
      const innerWalls = [
        { x: 3, y: 3, w: 4, h: 1 },
        { x: 13, y: 3, w: 4, h: 1 },
        { x: 3, y: 3, w: 1, h: 4 },
        { x: 16, y: 3, w: 1, h: 4 },
        { x: 8, y: 2, w: 4, h: 1 },
        { x: 5, y: 7, w: 3, h: 1 },
        { x: 12, y: 7, w: 3, h: 1 },
        { x: 8, y: 8, w: 1, h: 4 },
        { x: 11, y: 8, w: 1, h: 4 },
        { x: 3, y: 13, w: 4, h: 1 },
        { x: 13, y: 13, w: 4, h: 1 },
        { x: 3, y: 16, w: 1, h: 3 },
        { x: 16, y: 16, w: 1, h: 3 },
        { x: 8, y: 16, w: 4, h: 1 },
      ];
      
      innerWalls.forEach(wall => {
        for (let dx = 0; dx < wall.w; dx++) {
          for (let dy = 0; dy < wall.h; dy++) {
            walls.push({ x: wall.x + dx, y: wall.y + dy });
          }
        }
      });
    }
    
    function createCoins() {
      coins = [];
      powerPellets = [];
      
      // Place power pellets in corners
      const pelletPositions = [
        { x: 2, y: 2 },
        { x: 17, y: 2 },
        { x: 2, y: 17 },
        { x: 17, y: 17 }
      ];
      
      pelletPositions.forEach(pos => {
        if (!isWall(pos.x, pos.y)) {
          powerPellets.push({ x: pos.x, y: pos.y, pulse: 0 });
        }
      });
      
      // Place regular coins
      for (let x = 1; x < GRID_WIDTH - 1; x++) {
        for (let y = 1; y < GRID_HEIGHT - 1; y++) {
          if (!isWall(x, y) && 
              !(x === pacman.x && y === pacman.y) &&
              !powerPellets.some(p => p.x === x && p.y === y)) {
            coins.push({ x, y });
          }
        }
      }
    }
    
    function createGhosts() {
      ghosts = [
        { x: 18, y: 1, direction: 'left', color: '#ef4444', name: 'red', baseSpeed: 0.08 },
        { x: 1, y: 18, direction: 'right', color: '#3b82f6', name: 'blue', baseSpeed: 0.07 },
        { x: 18, y: 18, direction: 'up', color: '#ec4899', name: 'pink', baseSpeed: 0.09 },
        { x: 10, y: 10, direction: 'down', color: '#f97316', name: 'orange', baseSpeed: 0.08 }
      ];
      eatenGhosts = [];
      ghostRespawnTimers = [];
    }
    
    function isWall(x, y) {
      return walls.some(wall => wall.x === Math.floor(x) && wall.y === Math.floor(y));
    }
    
    function canMove(x, y) {
      const gridX = Math.floor(x);
      const gridY = Math.floor(y);
      return gridX >= 0 && gridX < GRID_WIDTH && gridY >= 0 && gridY < GRID_HEIGHT && !isWall(gridX, gridY);
    }
    
    function movePacman() {
      // Try to change direction if next direction is set
      if (pacman.nextDirection !== pacman.direction) {
        let testX = pacman.x;
        let testY = pacman.y;
        
        switch(pacman.nextDirection) {
          case 'up': testY -= pacman.speed; break;
          case 'down': testY += pacman.speed; break;
          case 'left': testX -= pacman.speed; break;
          case 'right': testX += pacman.speed; break;
        }
        
        if (canMove(testX, testY)) {
          pacman.direction = pacman.nextDirection;
        }
      }
      
      let newX = pacman.x;
      let newY = pacman.y;
      
      switch(pacman.direction) {
        case 'up': newY -= pacman.speed; break;
        case 'down': newY += pacman.speed; break;
        case 'left': newX -= pacman.speed; break;
        case 'right': newX += pacman.speed; break;
      }
      
      if (canMove(newX, newY)) {
        pacman.x = newX;
        pacman.y = newY;
        
        // Collect coin
        const pacmanGridX = Math.floor(pacman.x);
        const pacmanGridY = Math.floor(pacman.y);
        
        const coinIndex = coins.findIndex(coin => coin.x === pacmanGridX && coin.y === pacmanGridY);
        if (coinIndex !== -1) {
          coins.splice(coinIndex, 1);
          score += 10;
          updateScore();
          
          // Level up
          if (coins.length === 0 && powerPellets.length === 0) {
            level++;
            document.getElementById('level').textContent = level;
            resetLevel();
          }
        }
        
        // Collect power pellet
        const pelletIndex = powerPellets.findIndex(p => p.x === pacmanGridX && p.y === pacmanGridY);
        if (pelletIndex !== -1) {
          powerPellets.splice(pelletIndex, 1);
          score += 50;
          updateScore();
          activatePowerMode();
          
          // Level up check
          if (coins.length === 0 && powerPellets.length === 0) {
            level++;
            document.getElementById('level').textContent = level;
            resetLevel();
          }
        }
      }
      
      checkCollision();
    }
    
    function activatePowerMode() {
      powerMode = true;
      powerModeTimer = 20;
      document.getElementById('power-up-timer').style.display = 'block';
      updatePowerTimer();
    }
    
    function updatePowerTimer() {
      if (powerModeTimer > 0) {
        document.getElementById('power-time').textContent = powerModeTimer;
      } else {
        powerMode = false;
        document.getElementById('power-up-timer').style.display = 'none';
      }
    }
    
    function moveGhosts() {
      ghosts.forEach(ghost => {
        const speed = powerMode ? ghost.baseSpeed * 0.5 : ghost.baseSpeed;
        const directions = ['up', 'down', 'left', 'right'];
        
        // If in power mode, ghosts run away from pacman
        const dx = pacman.x - ghost.x;
        const dy = pacman.y - ghost.y;
        
        let preferredDir = [];
        if (powerMode) {
          // Run away from pacman
          if (Math.abs(dx) > Math.abs(dy)) {
            preferredDir = dx > 0 ? ['left', 'right'] : ['right', 'left'];
          } else {
            preferredDir = dy > 0 ? ['up', 'down'] : ['down', 'up'];
          }
        } else {
          // Chase pacman
          if (Math.abs(dx) > Math.abs(dy)) {
            preferredDir = dx > 0 ? ['right', 'left'] : ['left', 'right'];
          } else {
            preferredDir = dy > 0 ? ['down', 'up'] : ['up', 'down'];
          }
        }
        
        let moved = false;
        for (let dir of preferredDir) {
          let newX = ghost.x;
          let newY = ghost.y;
          
          switch(dir) {
            case 'up': newY -= speed; break;
            case 'down': newY += speed; break;
            case 'left': newX -= speed; break;
            case 'right': newX += speed; break;
          }
          
          if (canMove(newX, newY)) {
            ghost.x = newX;
            ghost.y = newY;
            ghost.direction = dir;
            moved = true;
            break;
          }
        }
        
        if (!moved) {
          const validMoves = directions.filter(dir => {
            let newX = ghost.x;
            let newY = ghost.y;
            const testSpeed = speed * 2;
            switch(dir) {
              case 'up': newY -= testSpeed; break;
              case 'down': newY += testSpeed; break;
              case 'left': newX -= testSpeed; break;
              case 'right': newX += testSpeed; break;
            }
            return canMove(newX, newY);
          });
          
          if (validMoves.length > 0) {
            const randomDir = validMoves[Math.floor(Math.random() * validMoves.length)];
            let newX = ghost.x;
            let newY = ghost.y;
            
            switch(randomDir) {
              case 'up': newY -= speed; break;
              case 'down': newY += speed; break;
              case 'left': newX -= speed; break;
              case 'right': newX += speed; break;
            }
            
            ghost.x = newX;
            ghost.y = newY;
            ghost.direction = randomDir;
          }
        }
      });
      
      checkCollision();
    }
    
    function checkCollision() {
      const pacmanGridX = Math.floor(pacman.x);
      const pacmanGridY = Math.floor(pacman.y);
      
      ghosts.forEach((ghost, index) => {
        const ghostGridX = Math.floor(ghost.x);
        const ghostGridY = Math.floor(ghost.y);
        const distance = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
        
        if (distance < 0.5) {
          if (powerMode) {
            // Eat ghost
            score += 200;
            updateScore();
            eatenGhosts.push(ghost.name);
            ghosts.splice(index, 1);
            
            // Set respawn timer
            ghostRespawnTimers.push({
              name: ghost.name,
              color: ghost.color,
              baseSpeed: ghost.baseSpeed,
              timeLeft: 20,
              originalIndex: index
            });
          } else {
            // Lose life
            lives--;
            updateLives();
            
            if (lives <= 0) {
              gameOver();
            } else {
              resetPositions();
            }
          }
        }
      });
    }
    
    function resetPositions() {
      pacman.x = 1;
      pacman.y = 1;
      pacman.direction = 'right';
      pacman.nextDirection = 'right';
      
      createGhosts();
      powerMode = false;
      powerModeTimer = 0;
      document.getElementById('power-up-timer').style.display = 'none';
    }
    
    function resetLevel() {
      resetPositions();
      createMaze();
      createCoins();
    }
    
    function gameOver() {
      clearInterval(gameLoop);
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 56px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2 - 40);
      
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 32px system-ui';
      ctx.fillText('Skor Akhir: ' + score, canvas.width / 2, canvas.height / 2 + 20);
      
      ctx.font = '20px system-ui';
      ctx.fillStyle = '#ffffff';
      ctx.fillText('Memulai ulang dalam 3 detik...', canvas.width / 2, canvas.height / 2 + 60);
      
      setTimeout(() => {
        score = 0;
        level = 1;
        lives = 3;
        updateScore();
        updateLives();
        document.getElementById('level').textContent = level;
        resetLevel();
        startGame();
      }, 3000);
    }
    
    function updateScore() {
      document.getElementById('score').textContent = score;
    }
    
    function updateLives() {
      const hearts = '‚ù§Ô∏è'.repeat(lives);
      document.getElementById('lives').textContent = hearts || 'üíÄ';
    }
    
    function drawPacman() {
      const config = window.elementSdk ? window.elementSdk.config : defaultConfig;
      const color = config.pacman_color || defaultConfig.pacman_color;
      
      ctx.fillStyle = color;
      ctx.beginPath();
      
      const centerX = pacman.x * CELL_SIZE + CELL_SIZE / 2;
      const centerY = pacman.y * CELL_SIZE + CELL_SIZE / 2;
      const radius = CELL_SIZE / 2 - 3;
      
      let startAngle, endAngle;
      if (pacman.mouthOpen) {
        switch(pacman.direction) {
          case 'right':
            startAngle = 0.2 * Math.PI;
            endAngle = 1.8 * Math.PI;
            break;
          case 'left':
            startAngle = 1.2 * Math.PI;
            endAngle = 0.8 * Math.PI;
            break;
          case 'up':
            startAngle = 1.7 * Math.PI;
            endAngle = 1.3 * Math.PI;
            break;
          case 'down':
            startAngle = 0.7 * Math.PI;
            endAngle = 0.3 * Math.PI;
            break;
        }
      } else {
        startAngle = 0;
        endAngle = 2 * Math.PI;
      }
      
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.lineTo(centerX, centerY);
      ctx.fill();
      
      // Add shadow for depth
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(251, 191, 36, 0.5)';
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    function drawGhosts() {
      ghosts.forEach(ghost => {
        const centerX = ghost.x * CELL_SIZE + CELL_SIZE / 2;
        const centerY = ghost.y * CELL_SIZE + CELL_SIZE / 2;
        const radius = CELL_SIZE / 2 - 3;
        
        // Body color changes in power mode
        if (powerMode) {
          ctx.fillStyle = '#1e40af';
        } else {
          ctx.fillStyle = ghost.color;
        }
        
        // Body
        ctx.beginPath();
        ctx.arc(centerX, centerY - 3, radius, Math.PI, 0, false);
        ctx.lineTo(centerX + radius, centerY + radius);
        ctx.lineTo(centerX + radius - 5, centerY + radius - 5);
        ctx.lineTo(centerX, centerY + radius);
        ctx.lineTo(centerX - radius + 5, centerY + radius - 5);
        ctx.lineTo(centerX - radius, centerY + radius);
        ctx.closePath();
        ctx.fill();
        
        // Eyes
        if (powerMode) {
          // Scared eyes
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(centerX - 6, centerY - 3, 3, 0, 2 * Math.PI);
          ctx.arc(centerX + 6, centerY - 3, 3, 0, 2 * Math.PI);
          ctx.fill();
        } else {
          // Normal eyes
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(centerX - 6, centerY - 3, 5, 0, 2 * Math.PI);
          ctx.arc(centerX + 6, centerY - 3, 5, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(centerX - 6, centerY - 3, 3, 0, 2 * Math.PI);
          ctx.arc(centerX + 6, centerY - 3, 3, 0, 2 * Math.PI);
          ctx.fill();
        }
      });
    }
    
    function drawCoins() {
      const config = window.elementSdk ? window.elementSdk.config : defaultConfig;
      const color = config.pacman_color || defaultConfig.pacman_color;
      
      ctx.fillStyle = color;
      coins.forEach(coin => {
        ctx.beginPath();
        ctx.arc(coin.x * CELL_SIZE + CELL_SIZE / 2, coin.y * CELL_SIZE + CELL_SIZE / 2, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
    }
    
    function drawPowerPellets() {
      const config = window.elementSdk ? window.elementSdk.config : defaultConfig;
      const color = config.power_pellet_color || defaultConfig.power_pellet_color;
      
      powerPellets.forEach(pellet => {
        pellet.pulse += 0.1;
        const radius = 8 + Math.sin(pellet.pulse) * 2;
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(pellet.x * CELL_SIZE + CELL_SIZE / 2, pellet.y * CELL_SIZE + CELL_SIZE / 2, radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }
    
    function drawWalls() {
      ctx.fillStyle = '#334155';
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 2;
      
      walls.forEach(wall => {
        ctx.fillRect(wall.x * CELL_SIZE + 2, wall.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        ctx.strokeRect(wall.x * CELL_SIZE + 2, wall.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
      });
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWalls();
      drawCoins();
      drawPowerPellets();
      drawGhosts();
      drawPacman();
    }
    
    function gameUpdate() {
      moveCounter++;
      
      if (moveCounter % 8 === 0) {
        pacman.mouthOpen = !pacman.mouthOpen;
      }
      
      movePacman();
      moveGhosts();
      
      // Update power mode timer
      if (powerMode && moveCounter % 60 === 0) {
        powerModeTimer--;
        updatePowerTimer();
        if (powerModeTimer <= 0) {
          powerMode = false;
          document.getElementById('power-up-timer').style.display = 'none';
        }
      }
      
      // Update ghost respawn timers
      ghostRespawnTimers.forEach((timer, index) => {
        if (moveCounter % 60 === 0) {
          timer.timeLeft--;
          
          if (timer.timeLeft <= 0) {
            // Respawn ghost
            const spawnPositions = [
              { x: 18, y: 1 },
              { x: 1, y: 18 },
              { x: 18, y: 18 },
              { x: 10, y: 10 }
            ];
            const spawnPos = spawnPositions[timer.originalIndex] || spawnPositions[0];
            
            ghosts.push({
              x: spawnPos.x,
              y: spawnPos.y,
              direction: 'left',
              color: timer.color,
              name: timer.name,
              baseSpeed: timer.baseSpeed
            });
            
            ghostRespawnTimers.splice(index, 1);
            eatenGhosts = eatenGhosts.filter(name => name !== timer.name);
          }
        }
      });
      
      draw();
    }
    
    function startGame() {
      gameLoop = setInterval(gameUpdate, 1000 / 60);
    }
    
    // Joystick controls
    let isDragging = false;
    
    joystickStick.addEventListener('mousedown', startDrag);
    joystickStick.addEventListener('touchstart', startDrag);
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag);
    
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
    
    function startDrag(e) {
      isDragging = true;
      e.preventDefault();
    }
    
    function drag(e) {
      if (!isDragging) return;
      
      e.preventDefault();
      const rect = joystickContainer.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      let clientX, clientY;
      if (e.type.includes('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      let deltaX = clientX - centerX;
      let deltaY = clientY - centerY;
      
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const maxDistance = 45;
      
      if (distance > maxDistance) {
        deltaX = (deltaX / distance) * maxDistance;
        deltaY = (deltaY / distance) * maxDistance;
      }
      
      joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
      
      // Determine direction
      const angle = Math.atan2(deltaY, deltaX);
      const absAngle = Math.abs(angle);
      
      if (distance > 15) {
        if (absAngle < Math.PI / 4) {
          pacman.nextDirection = 'right';
        } else if (absAngle > 3 * Math.PI / 4) {
          pacman.nextDirection = 'left';
        } else if (angle > 0) {
          pacman.nextDirection = 'down';
        } else {
          pacman.nextDirection = 'up';
        }
      }
    }
    
    function endDrag() {
      isDragging = false;
      joystickStick.style.transform = 'translate(-50%, -50%)';
    }
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          e.preventDefault();
          pacman.nextDirection = 'up';
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          e.preventDefault();
          pacman.nextDirection = 'down';
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          e.preventDefault();
          pacman.nextDirection = 'left';
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          e.preventDefault();
          pacman.nextDirection = 'right';
          break;
      }
    });

    async function onConfigChange(config) {
      const baseFontSize = config.font_size || defaultConfig.font_size;
      const customFont = config.font_family || defaultConfig.font_family;
      const baseFontStack = 'system-ui, -apple-system, sans-serif';
      
      document.getElementById('game-title').textContent = config.game_title || defaultConfig.game_title;
      document.getElementById('game-title').style.fontSize = `${baseFontSize * 3}px`;
      document.getElementById('game-title').style.fontFamily = `${customFont}, ${baseFontStack}`;
      
      document.getElementById('score-label').textContent = config.score_label || defaultConfig.score_label;
      document.getElementById('score-label').style.fontFamily = `${customFont}, ${baseFontStack}`;
      
      document.getElementById('lives-label').textContent = config.lives_label || defaultConfig.lives_label;
      document.getElementById('lives-label').style.fontFamily = `${customFont}, ${baseFontStack}`;
      
      document.getElementById('app').style.background = `linear-gradient(135deg, ${config.background_gradient_start || defaultConfig.background_gradient_start} 0%, ${config.background_gradient_end || defaultConfig.background_gradient_end} 100%)`;
      
      draw();
    }

    function mapToCapabilities(config) {
      return {
        recolorables: [
          {
            get: () => config.background_gradient_start || defaultConfig.background_gradient_start,
            set: (value) => {
              if (window.elementSdk) {
                window.elementSdk.config.background_gradient_start = value;
                window.elementSdk.setConfig({ background_gradient_start: value });
              }
            }
          },
          {
            get: () => config.background_gradient_end || defaultConfig.background_gradient_end,
            set: (value) => {
              if (window.elementSdk) {
                window.elementSdk.config.background_gradient_end = value;
                window.elementSdk.setConfig({ background_gradient_end: value });
              }
            }
          },
          {
            get: () => config.pacman_color || defaultConfig.pacman_color,
            set: (value) => {
              if (window.elementSdk) {
                window.elementSdk.config.pacman_color = value;
                window.elementSdk.setConfig({ pacman_color: value });
              }
            }
          },
          {
            get: () => config.power_pellet_color || defaultConfig.power_pellet_color,
            set: (value) => {
              if (window.elementSdk) {
                window.elementSdk.config.power_pellet_color = value;
                window.elementSdk.setConfig({ power_pellet_color: value });
              }
            }
          }
        ],
        borderables: [],
        fontEditable: {
          get: () => config.font_family || defaultConfig.font_family,
          set: (value) => {
            if (window.elementSdk) {
              window.elementSdk.config.font_family = value;
              window.elementSdk.setConfig({ font_family: value });
            }
          }
        },
        fontSizeable: {
          get: () => config.font_size || defaultConfig.font_size,
          set: (value) => {
            if (window.elementSdk) {
              window.elementSdk.config.font_size = value;
              window.elementSdk.setConfig({ font_size: value });
            }
          }
        }
      };
    }

    function mapToEditPanelValues(config) {
      return new Map([
        ["game_title", config.game_title || defaultConfig.game_title],
        ["score_label", config.score_label || defaultConfig.score_label],
        ["lives_label", config.lives_label || defaultConfig.lives_label]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }
    
    createMaze();
    createCoins();
    createGhosts();
    startGame();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9ab4ccc2118fea89',t:'MTc2NTI4NjQzMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>